第1题 谈谈变量提升？

  变量提升的概念：函数和变量的声明会被js的解释器放到最上面。
  js执行前有一个“预编译”过程
  预编译主要有两个任务：
  声明所有var变量（初始为undefined）。
  解析定义式函数语句。
  例子1：
  function fn1() {
      a = 2;
      console.log(a); 
      console.log(window.a); 
      var a = 8;
      console.log(a); 
    }
    fn1();
    输出结果依次为：2 undefined 8，因为代码在解析的时候相当于

      var a;//函数的声明会被解释器放到头部，预先声明，但没有赋值，所以在此刻a是undefined
       a = 2;
      console.log(a); 
      console.log(window.a); //此处打印的是全局变量的a，但是并没有声明全局变量a
      a = 8;
      console.log(a); 
     例子2：
     //全局作用域下
    a = 5;
    //全局作用域下
    var a = 5;
    都在全局作用域下执行两端代码有何区别？

    a=5相当于window.a=5。为全局window对象添加了一个属性a值为5
    var a=5相当于在全局作用域中声明了变量a，在整个作用域中都有效
    后者比前者多了一个声明的行为
    前者没有变量提升过程，提前访问会报错，后者有变量提升


第2题 说说bind、call、apply的 区别？

  bind、call、apply三者都是用来改变函数的this对象的指向的，第一个参数都是this,是prototype的方法。
  var xw = {
         name : "小王",
         gender : "男",
         age : 24,
         say : function(school,grade) {
            alert(this.name + " , " + this.gender + " ,今年" + this.age + " ,在" + school + "上" + grade);                               
         }
  }
  var xh = {
        name : "小红",
        gender : "女",
        age : 18
   }
   xw.say();
  对于call可以这样：
    xw.say.call(xh,"实验小学","六年级");
  对于apply可以这样：
    xw.say.apply(xh,["实验小学","六年级郑州牛皮癣医"]);
  而对于bind来说需要这样
    xw.say.bind(xh,"实验小学","六年级")();或者xw.say.bind(xh)("实验小学","六年级");
  从而可以看出call和apply都是对函数的直接调用，而bind方法返回的仍然是一个函数，因此后面还需要()来进行调用才可以。
  call方法传入的是字符串，而apply方法传入的是一个数组，因为call()是apply()的语法糖；
  需理解以下两个例子：
  const xw = {
        name : "小王",
        gender : "男",
        age : 24,
        say() {
            return this.name + " , " + this.gender + " ,今年" + this.age                               
        }
  }
  console.log(xw.say());
  //小王，男，今年24
  const person = {
        age: 20,
        getAge() {
          return this.age
        }
      }
  const getAge = person.getAge
  console.log(getAge())
  //undefined
  使用bind方法
  const getAge = person.getAge.bind(person)
  console.log(getAge())
  //20

第3题 如何实现一个 bind 函数？

  来自MDN:bind的介绍：
  bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。
  为什么要自己去实现一个bind函数？
  因为bind()函数在 ECMA-262 第五版才被加入；它可能无法在所有浏览器上运行。
  看下面一个例子：
  function animal(name) {
      this.name = name
  }
  let obj = {}

  let cat = animal.bind(obj)
  cat('lily')
  console.log(obj.name)  //lily

  let tom = new cat('tom')
  console.log(obj.name)  //lily
  console.log(tom.name)  //tom
  结果发现，obj.name依然是lily而没有变成tom，所以就像MDN描述的那样，如果绑定函数cat是通过new操作符来创建实例对象的话，
  this会指向创建的新对象tom，而不再固定绑定指定的对象obj。
  
  而bind函数的核心作用：绑定this、初始化参数。
  语法：fun.bind(thisArg[, arg1[, arg2[, ...]]])
  MDN:bind的实现如下：
  if (!Function.prototype.bind) {
  Function.prototype.bind = function(oThis) {
    if (typeof this !== 'function') {
      // closest thing possible to the ECMAScript 5
      // internal IsCallable function
      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
    }

    var aArgs = Array.prototype.slice.call(arguments, 1),//这里的arguments是跟oThis一起传进来的实参
      fToBind = this,
      fNOP    = function() {},
      fBound  = function() {
        return fToBind.apply(this instanceof fNOP
          ? this
          : oThis,
          // 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的
          aArgs.concat(Array.prototype.slice.call(arguments)));
      };

    // 维护原型关系
    if (this.prototype) {
      // Function.prototype doesn't have a prototype property
      fNOP.prototype = this.prototype;
    }
    fBound.prototype = new fNOP();

    return fBound;
  };
}
其中Array.prototype.slice.call(arguments)的意思是能将具有length属性的对象转成数组
由于arguments是类数组对象，不拥有数组的slice方法，所以需要通过call来将slice的this指向arguments。args就是调用bind时传入的初始化参数
（剔除了第一个参数oThis）。将args与绑定函数执行时的实参arguments通过concat连起来作为参数传入。
  
第4题 请实现一个 call 函数

  实现思路：
  1.改变this指向：可以将目标函数作为这个对象的属性
  2.利用arguments类数组对象实现参数不定长
  3.不能增加对象的属性，所以在结尾需要delete
  es6实现：
  Function.prototype.myCall = function (object, ...arg) {
      if (this === Function.prototype) {
          return undefined; // 用于防止 Function.prototype.myCall() 直接调用
      }
      let obj = Object(object) || window; // 加入这里没有参数，this则要指向window;
      obj.fn = this; // 将this的指向函数本身；
      obj.fn(...arg); // 对象上的方法，在调用时，this是指向对象的。
      delete obj.fn; // 再删除obj的_fn_属性,去除影响.
  }
  es5实现：
  Function.prototype.myCall = function(obj){
    let arg = [];
    for(let i = 1 ; i<arguments.length ; i++){
        arg.push( 'arguments[' + i + ']' ) ;
        // 这里要push 这行字符串  而不是直接push 值
        // 因为直接push值会导致一些问题
        // 例如: push一个数组 [1,2,3]
        // 在下面 eval调用时,进行字符串拼接,JS为了将数组转换为字符串 ，
        // 会去调用数组的toString()方法,变为 '1,2,3' 就不是一个数组了，相当于是3个参数.
        // 而push这行字符串，eval方法，运行代码会自动去arguments里获取值
    }
    obj._fn_ = this;
    eval( 'obj._fn_(' + arg + ')' ) // 字符串拼接，JS会调用arg数组的toString()方法，这样就传入了所有参数
    delete obj._fn_;
 } 

第5题 如何实现一个 apply 函数？

  对比call和apply之间的差别，就会发现，它们的实现原理只有一点点差别，那就是后面的参数不一样，apply的第二个参数是一个数组，
  所以可以拿call的实现方法稍微改动一下就可以了
  Function.prototype.myApply = function (object, arg) {
    let obj = Object(object) || window; // 如果没有传this参数，this将指向window
    obj.fn = this; // 将this的指向函数本身；
    obj.fn(arg); // 这里不要将数组打散，而是将整个数组传进去;
    delete obj.fn; // 再删除obj的_fn_属性,去除影响.
  }

第6题 简单说下原型链？

  凡是对象都有原型，原型也是对象，也具有原型，也就是原型的原型，如此下去，会构成一个对象序列，该结构即为原型链。
  简化为：
  每个函数 function 都有一个prototype属性，即 显式原型
  每个实例对象都有一个__proto__，可称为隐式原型
  实例对象的隐式原型的值 === 其对应构造函数的显示原型的值
  而原型链的别名为隐式原型链
  当前对象的__proto__属性下的constructor属性的类型是当前对象的真实类型，那么当前对象的原型也就是构造函数
  类型.prototype。根据此结论往下推到，__proto__属性里的__proto__属性里的constructor属性类型也就是__proto__原型对象的真实类型，
  __proto__原型对象的原型对象也是构造函数.prototype。（__proto__对象的真实类型是Object，__proto__的原型对象是Object.prototype）        Object.prototype的原型对象是null，也就到头了。

第7题 怎么判断对象类型？

  toString实现，toString()是定义在Object.prototype上的实例方法，所有实例对象继承了该方法，其可以返回一个对象的字符串形式。
  先看下面的情况
  'abc'.toString(); // "abc"
  [1,2].toString(); // "1,2"
  new Date().toString(); // "Sun Mar 24 2019 16:08:58 GMT+0800"
  然而很明显字符串、数组、Date等对象拥有自定义的toString方法，会覆盖Object.prototype.toString方法。
  此时配合call()，改变toString方法执行时的所在的环境，可以得到对象的精确类型。
  bject.prototype.toString.call('') // "[object String]"
  Object.prototype.toString.call([]) // "[object Array]"
  Object.prototype.toString.call(new Date()) // "[object Date]"

第8题 说说箭头函数的特点

  1.没有this
  2.不能使用new 构造函数
  3.不绑定arguments，用rest参数…解决
  4.捕获其所在上下文的 this 值，作为自己的 this 值
  5.箭头函数没有原型属性
  6.箭头函数不能当做Generator函数,不能使用yield关键字
  7.箭头函数不能换行
  8.箭头函数写法更加简洁

第9题 如何确定This指向

  this指向，简单来说就是谁调用，this就指向谁。
  此处this主要针对顶层对象为window进行阐述
  分情况来，主要有以下五种
  1.普通函数调用
    function demo() {
        console.log(this);  // window
    }
    demo();
    当函数作为函数独立调用的时候，则是在全局环境中运行，this 则指向全局对象 window
    此处demo 函数独立调用，所以 this 指向全局对象 window
    再如：
    function outer() {
      function inner() {
          console.log(this); // window
      }
      inner();
    }
    outer();
    
    function demo(func) {
        func();
    }
    demo(function () {
        console.log(this); // window
    });
    虽然在 outer 函数内部声明了一个 inner 函数，但实际上 inner 函数是独立调用的，所以依然是在全局环境，this仍然是指向了 window。
    给demo函数传入一个匿名函数，执行匿名函数func的时候，依然是作为函数独立调用，所以this仍然指向window。
    理解一下什么是作为函数独立调用：
    当定义一个函数，例如var demo = function () {} 等号右边的函数是独立放在内存中的，然后赋予demo变量的指向为函数所在的内存地址，
    当直接调用 demo()，相当于直接找到函数本身执行，所以函数内部创建的上下文为全局上下文，this 则指向了全局对象 window。
    
  2.对象方法调用
    当调用一个对象方法时，this 代表了对象本身。
    let obj = {
        name: 'invoker',
        getName: function () {
            console.log(this);   // obj
            console.log(this.name);  // "invoker"
        }
    }
    obj.getName();
    定义了一个 obj 对象，调用其内部的getName，this 则指向了 obj 对象。
    稍微修改一下

    var name = 'windowName';
    let obj = {
        name: 'invoker',
        getName: function () {
            console.log(this);  // window
            console.log(this.name); // windowName
        }
    }
 
    var getName = obj.getName;
    getName();
    当用一个变量 getName 接收 obj 对象的 getName方法， 再执行 getName，发现 this 指向了 window，因为此时变量 getName 直接指向了函数本身，
    而不是通过 obj 去调用，此时就变成了函数独立调用的情况了。
    再看个例子

    let obj = {
        test: function() {
            function fn() {
                console.log(this); // window
            }
            fn();
        },
        test1: function (fn) {
            fn()
        }
    }

    obj.test();
    obj.test1(function () {
        console.log(this) // window
    });
    虽然在 obj 对象的 test 方法内定义了 fn ，但执行时同样属于函数独立调用，所以 this 指向 window。
    将函数作为参数传入 obj 的 test1 方法，也属于函数独立调用，this 同样指向 window。
  3.构造函数调用
    使用 new 关键字调用函数，则是构造函数调用，this 指向了该构造函数新创建的对象。

    function person(name) {
        this.name = name
    }

    let p = new person('invoker')
    console.log(p.name) // 'invoker'
    回顾一下 new 关键词的过程：

    创建一个新的对象 obj
    使得 obj 的 __proto__ 指向 构造函数的原型对象
    执行构造函数中的 constructor，改变this的指向为 obj
    如果结果是对象类型，则返回结果，否则返回obj
    function myNew(Fn) {
        let obj = {}
        obj.__proto__ = Fn.prototype

        const res = Fn.prototype.constructor.call(obj)
        if (typeof res === 'object') {
            obj = res
        }

        return obj
    }
  4.call、apply、bind
    this 指向的是 call 、 apply、bind 调用时传递的第一个参数。

    let obj = {
        name: 'invoker'
    }

    function demo() {
        console.log(this.name) // 'invoker'
    }

    demo.call(obj)
    demo.apply(obj) 
    demo.bind(obj)() 
  5.箭头函数
  箭头函数在执行时并不会创建自身的上下文，它的 this 取决于自身被定义的所在执行上下文。

  例子：

      let obj = {
          fn: () => {
              console.log(this) // window
          }
      }

      obj.fn()
  obj 的 fn 指向一个箭头函数，由于只有函数可以创建执行上下文，而箭头函数外部并没有包裹函数，所以箭头函数所在的执行上下文为全局的执行上下文，
  this 指向 window

  包裹一个函数看看呗？

      let obj = {
          fn: function () {
              console.log('箭头函数所在执行上下文', this) // '箭头函数所在执行上下文' obj

              var arrow = () => {
                  console.log(this) //obj
              }
              arrow()
          }
      }

      obj.fn()
  箭头函数 arrow 被定义在 obj.fn 内，所以 fn 中的 this 就是 arrow 中的 this

  箭头函数一次绑定上下文后便不可更改：

      let obj = { name: 'invoker' }

      var demo = () => {
          console.log(this) // window
      }

      demo.call(obj)
  虽然使用了 call 函数间接修改 this 的指向，但并不起作用。
  
  为什么会有this的设计
  javascript中存在 this 的设计，跟其内存中的数据结构有关系。

  假设定义 let obj = { name: 'invoker' }

  此时会先生成一个对象 { name: 'invoker' } 并放在内存当中
  将 { name: 'invoker } 所在的内存地址赋予 obj
  所以 obj 其实就是个指向某个对象的地址，如果要读取 obj.name，则先要找到 obj 所在地址，然后从地址中拿到原始对象，读取 name 属性。

  对象中每个属性都有一个属性描述对象：可通过 Object.getOwnPropertyDescriptor(obj, key) 来读取。
  也就是说上面所说的 obj 的 name 属性实际是下面这样的

  {
    name: {
      [[value]]: 'invoker',
      [[configurable]]: true,
      [[enumerable]]: true,
      [[writable]]: true
    }
  }
  value 就是获得的值。

  现在假设对象的属性是一个函数：

      let name = 'windowName'
      let obj = {
          name: 'invoker',
          sayHello: function () {
              console.log('my name is ' + this.name)
          }
      }

      let descriptor = Object.getOwnPropertyDescriptor(obj, 'sayHello')
      console.log(descriptor)

      //这个sayHello的属性描述对象为:
        sayHello: {
          [[value]]: ƒ (),
          [[configurable]]: true,
          [[enumerable]]: true,
          [[writable]]: true
        }
  sayHello 的 value 值是一个函数，这个时候，引擎会单独将这个函数放在 内存 当中，然后将函数的内存地址赋予 value。

  因此可以得知，这个函数在 内存 中是单独的，并不被谁拥有，所以它可以在不同的上下文执行。

  由于函数可以在不同上下文执行，所以需要一种机制去获取当前函数内部的执行上下文。所以，就有了 this，它指向了当前函数执行的上下文。

  // 接着上面代码

      obj.sayHello() // my name is invoker

      let sayHello = obj.sayHello
      sayHello() // my name is windowName
  obj.sayHello() 是通过 obj 找到 sayHello，也就是对象方法调用，所以就是在 obj 环境执行。
  当 let sayHello = obj.sayHello，变量 sayHello 就直接指向函数本身，所以 sayHello() 也就是函数独立调用，所以是全局环境执行。

第10题 async、await 的优缺点
第11题 generator 原理
第12题 对Promise的理解
第13题 == 和 ===区别，什么情况用 ==
第14题 垃圾回收 新生代算法，老生代算法
第15题 说说你对闭包的理解
第16题 基本数据类型和引?类型在存储上的差别
第17题 浏览器 Eventloop 和 Node 中的有什么区别
第18题 怎样理解setTimeout 执行误差
第19题 说说函数节流和防抖
第20题 数组降维
第21题 请实现一个深拷贝
第22题 typeof 于 instanceof 区别
第23题 cookie和localSrorage、session、indexDB 的区别
第24题 怎么判断页面是否加载完成？
第25题 说说 jsonp 原理
第26题 说说你对Service worker的理解
第27题 说说浏览器缓存机制
第28题 怎样选择合适的缓存策略
第29题 说说重绘（Repaint）和回流（Reflow）
第30题 如何优化图片
第31题 页面首屏渲染性能优化方案有哪些
第32题 浏览器性能问题-使用 Webpack 优化项目
第33题 Babel 原理
第34题 介绍下React 生命周期
第35题 react setState 机制
第36题 Vue的 nextTick 原理
第37题 Vue 生命周期
第38题 Vue 双向绑定
第39题 v-model原理
第40题 watch 和 computed 的区别和运用的场景
第41题 Vue 的父子通信
第42题 简述路由原理
第43题 MVVM-脏数据检测
第44题 MVVM-数据劫持
第45题 React V16 生命周期函数用法
第46题 Vue 和 React 区别
第47题 介绍下虚拟 DOM，对虚拟 DOM 的理解
第48题 路由鉴权
第49题 TCP 3次握手
第50题 TCP 拥塞控制
第51题 慢开始算法
第52题 拥塞避免算法
第53题 tcp 快速重传
第54题 TCP New Ren 改进后的快恢复
第55题 HTTPS 握手
第56题 从输入 URL 到页面加载全过程
第57题 HTTP 常用状态码 301 302 304 403
第58题 常见排序-冒泡排序
第59题 常见排序-插入排序
第60题 常见排序-选择排序
第61题 常见排序-归并排序
第62题 常见排序-快排
第63题 常见排序-堆排序
第64题 常见排序-系统自带排序实现
第65题 介绍下设计模式-工厂模式
第66题 介绍下设计模式-单例模式
第67题 介绍下设计模式-适配器模式
第68题 介绍下设计模式-装饰模式
第69题 介绍下设计模式-代理模式
第70题 介绍下设计模式-发布-订阅模式
第71题 Vue 响应式原理
第72题 实现一个new操作符
第73题 实现一个JSON.stringify
第74题 实现一个JSON.parse
第75题 手写一个继承
第76题 实现一个JS函数柯里化
第77题 请手写一个Promise(中高级必考)
第78题 手写防抖(Debouncing)和节流(Throttling)
第79题 实现一个instanceOf
第80题 实现一个私有变量
第81题 使用setTimeout代替setInterval进行间歇调用
第82题 数组中的forEach和map的区别
第83题 for in和for of的区别
第84题 写一个发布订阅 EventEmitter方法
第85题 let、var、const区别
第86题 typeof和instanceof 区别
第87题 常见的继承的几种方法
第88题 常见的浏览器内核有哪些?
第89题 浏览器的主要组成部分是什么？
第90题 浏览器是如何渲染UI的？
第91题 浏览器如何解析css选择器？
第92题 DOM Tree是如何构建的？
第93题 重绘与重排的区别？
第94题 如何触发重排和重绘？
第95题 如何避免重绘或者重排？
第96题 前端如何实现即时通讯？
第97题 什么是浏览器同源策略？
第98题 怎样解决跨域问题？
第99题 时间格式化
第100题 说说对html 语义化的理解
第101题 说说常用的 meta 标签
第102题 说说两种盒模型以及区别
第103题 css reset 和 normalize.css 有什么区别
第104题 怎样让元素水平垂直居中
第105题 说说选择器的权重计算方式
第106题 清除浮动的方
